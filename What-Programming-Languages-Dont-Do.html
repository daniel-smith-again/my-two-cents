<!DOCTYPE html>
<head>
<meta charset='utf-8'>
<link rel='stylesheet' href='style.css'>
<title>What Programming Languages Don't Do</title>
</head>
<body><div>
<pre>
 <a href="What-Programming-Languages-Dont-Do.html">link</a>                                                                      <a href="index.html">home</a>
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║                     What Programming Languages Don't Do                      ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝

       Programming languages have come a long way since they first made the 
transition from a formal theory to a practical skill. There's been many 
advancements, most of which have been necessitated by the existence of Lisp. 
But things have changed drastically since the invention of Lisp. We have the 
personal computer, the smartphone, massively distributed systems, homogeneous
computer architecture, multiple concurrent processing units in a single system,
and almost everything has a screen attached. Our use cases and requirements for
a general purpose, "system programming language" have changed.

       Much of the discourse around programming languages is what they do do, 
or the wishy-washy user experience ergonomics of a language and its tooling.
I find "friction" to be a deeply uninteresting topic. I would never talk about 
a runny nose when I could talk about the malady causing it instead. So below, 
you'll find a list of the current "maladies" which plague programming languages
and their tooling.


                           Behold, my list of gripes.
                           ──────────────────────────

┌
│ Math
└
       This one is low hanging fruit. Every programming language with the 
exception of Scheme and Mathematica do not do math. If a language provides 
anything at all outside of integers, it's always IEEE 754 floating point.
That's nice and all, but it's not math. At best, you're accurate to the 
thousandth's place. Unless you chain more than a few operations together in 
which case rounding error gives you nonsense answers. If you want math, the 
answer is normally to "use GMP". There's lots of room for improvement in this 
space.


┌
│ Executable Formats
└
       There is a prevalent inability to properly work with executable formats.
It's also an inexplicable prevalence. Executable formats haven't changed in the
last thirty years. There's three: PE, ELF, or MACH. That's it. That's the three.
Additionally, those three all essentially do the same thing, they have a 
hash-table or flat list of names (essentially goto labels) and flat segments of
machine instructions or binary data that those names refer to. That's it. 
That's all that's in an executable format. Yet somehow, we still have problems
like simply embedding binary data in a binary data segment, name mangling, and
ABI mismatch within the same language and toolset. These are hard problems,
but the reason they're hard is because we have incredibly poor support for 
manipulating these very simply tabular binary formats.


┌
│ Garbage Collection or Bust
└
       Your only two options are garbage collection or manual memory management.
If you don't like either one, you can use borrow checked manual memory
management. Wow. 

       There's reference counting, but tell me one language that's being 
actively used which relies on a referenced counted runtime. I'll wait.


┌
│ "Checkers"
└
       Static typing is a plague upon this earth. No, not that static typing, 
the other static typing. The one people are talking about when they say "HM" 
and nobody knows what they mean. The static typing that uses anything beginning
with the word "Algebraic". Those kinds of static typing are legos. They scratch
the itch in our brain because it feels like you're removing entropy, but you're
not actually accomplishing anything. Real type systems perform some form of 
static verification. For example, the SPARK subset of Ada. Real type systems 
check for type errors beyond mismatched independent variables. In the ML family
of languages, you can write a function signature that looks like  
                                   a -&gt; a -&gt; b
.... and they expect us to take them seriously. All this tells me is that the 
return argument is different, and the first two arguments are the same type. 
Fascinating! Clearly this is at the forefront of modern programming language 
design. 

       The issue isn't necessarily that these kinds of type systems are wrong,
it's just that they're touted as making your program safer or enforcing some 
desirable property beyond "a" being the same as "a" and different than "b".

</pre>
</div>
</body>
<footer>
<pre>
╭──────────────────────────────────────────────────────────────────────────────╮
│                    This page is Copyright © Daniel Smith                     │
╰──────────────────────────────────────────────────────────────────────────────╯
</pre>
</footer>
